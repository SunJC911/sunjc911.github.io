---
title: 代码随想录LeetCode(一刷，加油)
description: 
date: 2022-08-09
categories:
 - 代码随想录
tags:
 - 代码随想录
 - LeetCode
excerpt_separator: <!--more--> 

---



**好好学习，不然工资低到还不起房贷，结不起婚，买不起车子，照顾不了家人。**

一刷未涉及：VIM、大厂研发流程、如何搭建一台服务器、如何搭建git私服、求职、部分算法性能分析

陌生题目：844，977，209，904，76，59

未刷题目：76（数组-长度最小的子数组-相关题目推荐，想**刷到哈希表再做**）

<!--more--> 

## 编程素养

### 代码风格

python：小写字母加下划线。如 def case_1

### 库函数

熟悉库函数内的如何实现及时间复杂度，则可用，不熟练则自己敲。

### 代码模式

ACM（全自己写）与核心代码模式（写核心）

### VIM（未涉猎）

### Markdown

建议统一使用，软件Typora（win）和macdown（mac）

https://markdown-it.github.io/

### 大厂研发流程（未看）

### 如何搭建一台服务器（未看）

### 如何搭建git私服（未看）

## 求职（整章未看）

## 算法性能分析

### 时间复杂度分析

什么是时间复杂度？**时间复杂度是一个函数，它定性描述该算法的运行时间**。估算算法的操作单元数量来代表程序消耗的时间，假设每个操作单元运行时间相同。

记为大O，如T(n) = O(f(n))，**大O为上界，即最坏情况**。

下图为不同算法的时间复杂度在不同数据输入规模下的差异。

![time_complexity_coordinates](https://sunjc911.github.io/assets/images/DMSXLLeetCode1/time_complexity_coordinates.png)

下图为常见排序时间复杂度。

![common_o](https://sunjc911.github.io/assets/images/DMSXLLeetCode1/common_o.png)

忽略常数项的原因：大O就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是**常数项系数已经不起决定性作用**的数据量。常数非常大如10的7 8 次方还需考虑。

时间复杂度一般排行：

O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n^2)平方阶 < O(n^3)立方阶 < O(2^n)指数阶

**化简方法**见代码随想录。

### 算法为什么会超时（未细看）

### 递归算法的时间复杂度（未看）

### 算法性能分析系列一（未看）

### 空间复杂度分析（未看）

### 递归算法的性能分析(未看)

### 代码的内存消耗（未看）

## 数组

### 数组理论基础

- **数组是存放在连续内存空间上的相同类型数据的集合**
- **数组下标都是从0开始的**
- **数组内存空间的地址是连续的**
- **数组元素不能删除，只能覆盖**

### 二分查找（704）

**看清题目条件。**

看到**有序数组和O(logn)**要想到二分查找。

`n = len(nums) - 1 `

#### 相关题目推荐

##### 搜索插入位置（35）

记得**看提示**里的东西。

##### 在排序数组中查找元素的第一个和最后一个位置（34）

函数内的函数定义不用self

##### x的平方根（69）

##### 有效的完全平方数（367）

### 移除元素（27）

数组的元素在内存地址中是**连续**的，不能单独删除数组中的某个元素，只能**覆盖**。

**双指针法**（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。

双指针法（快慢指针法）在**数组和链表的操作中**是非常常见的，很多考察**数组、链表、字符串**等操作的面试题，都使用双指针法。

#### 相关题目推荐

##### 删除排序数组中的重复项（26）

##### 移动零（283）

##### 比较含退格的字符串（844）

### 有序数组的平方（977）

方法一：直接排序

**sorted()** 作为Python内置函数之一，其功能是对序列（列表、元组、字典、集合、还包括字符串）进行排序。不会对原序列排序，需要额外空间。

`return sorted(num * num for num in nums)`

方法二：找负数和非负数的分界线

`for i, num in enumerate(nums):
            if num < 0:
                negative = i
            else:
                break`

**enumerate()** 函数，一般用于for循环中，用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标。

`enumerate(sequence, [start=0])  # start为下标从几开始`

方法三：**创造一个值全为0的list**，比较后把大的倒插

### 长度最小的子数组（209）

方法一：暴力双for循环可以解，但是leetcode给其规定为超时 O(n^2)

方法二：滑动窗口（双指针的一种）O(n)

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

保存最短子序列长度很关键

定义无限大的数 ` res = float("inf")`

**方法三：前缀和 + 二分查找**

```
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        def func(s, t):
            left = 0
            n = len(s)
            right = n - 1
            while left <= right:
                mid = (left + right) // 2
                if s[mid] < t:
                    left = mid + 1
                else :
                    right = mid - 1
            return left
                
        n = len(nums)
        sums = [0]
        ans = n + 1
        for i in range(n):
            sums.append(sums[-1] + nums[i])
        
        for i in range(0, n):
            tal = target + sums[i]
            bound = func(sums, tal)
            if bound != len(sums):
                ans = min(ans, bound - i)  # 理解清楚bound - i ！！！！
        # bound - i: 说明sums[bound] - sums[i] 的值大于等于target。
        return 0 if ans == n + 1 else ans
```

#### 相关题目推荐

##### 水果成篮（904）

方法一：按块扫描

itertools，它主要是提供迭代类的操作。

迭代器的特点是：**惰性求值（Lazy evaluation）**，即只有当迭代至某个值时，它才会被计算，这个特点使得迭代器特别适合于遍历大文件或无限集合等，因为我们不用一次性将它们存储在内存中。

```
blocks = [(k, len(list(v))) for k, v in itertools.groupby(tree)]
```

set()添加：.add()

方法二：滑动窗口

collections是Python内建的一个集合模块，提供了许多有用的集合类和方法。

可以把它理解为一个容器，里面提供Python标准内建容器 dict , list , set , 和 tuple 的替代选择。

```
count = collections.Counter()  # 计数功能
for j, x in enumerate(tree):  # enumerate() 重要
```

##### 最小覆盖子串（76）（不会做）

### 螺旋矩阵Ⅱ（59）

